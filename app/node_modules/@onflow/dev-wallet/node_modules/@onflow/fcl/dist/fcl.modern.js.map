{"version":3,"file":"fcl.modern.js","sources":["../src/default-config.js","../src/resolve/index.js","../src/send/index.js","../src/serialize/index.js","../src/decode/index.js","../src/transaction/index.js","../src/events/index.js","../src/address/index.js","../src/current-user/render-frame.js","../src/current-user/fetch-services.js","../src/current-user/merge-services.js","../src/current-user/url-from-service.js","../src/current-user/render-authz-frame.js","../src/current-user/poll-for-authz-updates.js","../src/current-user/validate-composite-signature.js","../src/current-user/uid.js","../src/current-user/exec-authz-service.js","../src/current-user/index.js","../src/current-user/render-authn-frame.js","../src/current-user/service-of-type.js","../src/fcl.js"],"sourcesContent":["import {config} from \"@onflow/config\"\n\nconfig()\n  .put(\"accessNode.api\", \"http://localhost:8080\")\n  .put(\"challenge.handshake\", \"http://localhost:8700/authenticate\")\n","import {\n  resolve as sdkResolve,\n  resolveParams,\n  resolveArguments,\n  resolveAccounts,\n  resolveSignatures,\n  resolveValidators,\n  resolveRefBlockId,\n  // resolveProposerSequenceNumber,\n} from \"@onflow/sdk\"\nimport {config} from \"@onflow/config\"\n\nexport const resolve = async ix => {\n  return sdkResolve(ix, [\n    resolveRefBlockId({node: await config().get(\"accessNode.api\")}),\n    // resolveProposerSequenceNumber({ node: await config().get(\"accessNode.api\") }),\n    resolveParams,\n    resolveArguments,\n    resolveAccounts,\n    resolveSignatures,\n    resolveValidators,\n  ])\n}\n","import {build, send as sdkSend} from \"@onflow/sdk\"\nimport {config} from \"@onflow/config\"\nimport {resolve} from \"../resolve\"\n\nexport const send = async (args = [], opts = {}) => {\n  opts.node = opts.node || (await config().get(\"accessNode.api\"))\n  if (Array.isArray(args)) args = build(args)\n  return sdkSend(await resolve(args), opts)\n}\n","import {build} from \"@onflow/sdk\"\nimport {resolve} from \"../resolve\"\n\nexport const serialize = async (args = []) => {\n  if (Array.isArray(args)) args = await build(args)\n  return JSON.stringify(await resolve(args))\n}\n","import {decodeResponse} from \"@onflow/sdk\"\nimport {config} from \"@onflow/config\"\n\nexport const decode = async response => {\n  const decodersFromConfig = await config().where(/^decoder\\./)\n  const decoders = Object.fromEntries(\n    Object.entries(decodersFromConfig).map(([pattern, xform]) => {\n      pattern = `/${pattern.replace(/^decoder\\./, \"\")}$/`\n      return [pattern, xform]\n    })\n  )\n  return decodeResponse(response, decoders)\n}\n","import \"../default-config\"\nimport {config} from \"@onflow/config\"\nimport {\n  spawn,\n  send,\n  subscriber,\n  snapshoter,\n  UPDATED,\n  SNAPSHOT,\n  INIT,\n  SUBSCRIBE,\n  UNSUBSCRIBE,\n} from \"@onflow/util-actor\"\nimport {send as fclSend} from \"../send\"\nimport {decode} from \"../decode\"\nimport {getTransactionStatus} from \"@onflow/sdk\"\n\nconst RATE = 2500\nconst POLL = \"POLL\"\n\nconst fetchTxStatus = async transactionId => {\n  const response = await fclSend([getTransactionStatus(transactionId)])\n  return decode(response)\n}\n\nconst isExpired = tx => tx.status === 5\nconst isSealed = tx => tx.status >= 4\nconst isExecuted = tx => tx.status >= 3\nconst isFinalized = tx => tx.status >= 2\nconst isPending = tx => tx.status >= 1\nconst isUnknown = tx => tx.status >= 0\n\nconst isDiff = (cur, next) => {\n  return JSON.stringify(cur) !== JSON.stringify(next)\n}\n\nconst HANDLERS = {\n  [INIT]: async ctx => {\n    const tx = await fetchTxStatus(ctx.self())\n    if (!isSealed(tx)) setTimeout(() => ctx.sendSelf(POLL), RATE)\n    ctx.merge(tx)\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from)\n    ctx.send(letter.from, UPDATED, ctx.all())\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from)\n  },\n  [SNAPSHOT]: async (ctx, letter) => {\n    letter.reply(ctx.all())\n  },\n  [POLL]: async ctx => {\n    const tx = await fetchTxStatus(ctx.self())\n    if (!isSealed(tx)) setTimeout(() => ctx.sendSelf(POLL), RATE)\n    if (isDiff(ctx.all(), tx)) ctx.broadcast(UPDATED, tx)\n    ctx.merge(tx)\n  },\n}\n\nconst scoped = transactionId => {\n  if (typeof transactionId === \"object\")\n    transactionId = transactionId.transactionId\n  if (transactionId == null) throw new Error(\"transactionId required\")\n  return transactionId\n}\n\nconst spawnTransaction = transactionId => {\n  return spawn(HANDLERS, scoped(transactionId))\n}\n\nexport function transaction(transactionId) {\n  function snapshot() {\n    return snapshoter(transactionId, spawnTransaction)\n  }\n\n  function subscribe(callback) {\n    return subscriber(scoped(transactionId), spawnTransaction, callback)\n  }\n\n  function once(predicate) {\n    return function innerOnce(opts = {}) {\n      const suppress = opts.suppress || false\n      return new Promise((resolve, reject) => {\n        const unsub = subscribe(txStatus => {\n          if (txStatus.statusCode && !suppress) {\n            reject(txStatus.errorMessage)\n            unsub()\n          } else if (predicate(txStatus)) {\n            resolve(txStatus)\n            unsub()\n          }\n        })\n      })\n    }\n  }\n\n  return {\n    snapshot,\n    subscribe,\n    onceFinalized: once(isFinalized),\n    onceExecuted: once(isExecuted),\n    onceSealed: once(isSealed),\n  }\n}\n\ntransaction.isUnknown = isUnknown\ntransaction.isPending = isPending\ntransaction.isFinalized = isFinalized\ntransaction.isExecuted = isExecuted\ntransaction.isSealed = isSealed\ntransaction.isExpired = isExpired\n","import {spawn, subscriber, SUBSCRIBE, UNSUBSCRIBE} from \"@onflow/util-actor\"\nimport {config} from \"@onflow/config\"\nimport {getLatestBlock, getEvents} from \"@onflow/sdk\"\nimport {send} from \"../send\"\nimport {decode} from \"../decode\"\n\nconst RATE = 10000\nconst UPDATED = \"UPDATED\"\nconst TICK = \"TICK\"\n\nconst currentBlock = async () => {\n  return decode(await send([getLatestBlock()]))\n}\n\nconst scheduleTick = async ctx => {\n  return setTimeout(\n    () => ctx.sendSelf(TICK),\n    await config().get(\"fcl.eventPollRate\", RATE)\n  )\n}\n\nconst HANDLERS = {\n  [TICK]: async ctx => {\n    if (!ctx.hasSubs()) return\n    let hwm = ctx.get(\"hwm\")\n    if (hwm == null) {\n      ctx.put(\"hwm\", await currentBlock())\n      ctx.put(\"tick\", await scheduleTick(ctx))\n    } else {\n      let next = await currentBlock()\n      ctx.put(\"hwm\", next)\n      const resp = await send([\n        getEvents(ctx.self(), hwm.height, next.height - 1),\n      ])\n      const data = await decode(resp)\n      for (let d of data) ctx.broadcast(UPDATED, d.data)\n      ctx.put(\"tick\", await scheduleTick(ctx))\n    }\n  },\n  [SUBSCRIBE]: async (ctx, letter) => {\n    if (!ctx.hasSubs()) {\n      ctx.put(\"tick\", await scheduleTick(ctx))\n    }\n    ctx.subscribe(letter.from)\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from)\n    if (!ctx.hasSubs()) {\n      clearTimeout(ctx.get(\"tick\"))\n      ctx.delete(\"tick\")\n      ctx.delete(\"hwm\")\n    }\n  },\n}\n\nconst spawnEvents = key => spawn(HANDLERS, key)\n\nexport function events(key) {\n  return {\n    subscribe: callback => subscriber(key, spawnEvents, callback),\n  }\n}\n","export function sansPrefix(address) {\n  if (address == null) return null\n  return address.replace(/^0x/, \"\")\n}\n\nexport function withPrefix(address) {\n  if (address == null) return null\n  return \"0x\" + sansPrefix(address)\n}\n","const FRAME_ID = \"FCL_IFRAME\"\n\nexport function renderFrame(src) {\n  if (document.getElementById(FRAME_ID)) return\n\n  const $frame = document.createElement(\"iframe\")\n  $frame.src = src\n  $frame.id = FRAME_ID\n  $frame.allow = \"usb\"\n  $frame.style.position = \"fixed\"\n  $frame.style.top = \"0px\"\n  $frame.style.right = \"0px\"\n  $frame.style.left = \"0px\"\n  $frame.style.bottom = \"0px\"\n  $frame.style.height = \"100vh\"\n  $frame.style.width = \"100vw\"\n  $frame.style.display = \"block\"\n  $frame.style.background = \"rgba(0,0,0,0.25)\"\n  $frame.frameBorder = \"0\"\n  $frame.style.boxSizing = \"border-box\"\n  $frame.style.border = \"1px solid white\"\n  document.body.append($frame)\n\n  const unmount = () => {\n    if (document.getElementById(FRAME_ID)) {\n      document.getElementById(FRAME_ID).remove()\n    }\n  }\n\n  return [$frame, unmount]\n}\n","export async function fetchServices(servicesURL, code) {\n  if (servicesURL == null || code == null) return []\n\n  const url = new URL(servicesURL)\n  url.searchParams.append(\"code\", code)\n\n  const resp = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  }).then(d => d.json())\n\n  if (Array.isArray(resp)) return resp\n\n  // Backwards compatibility for First-Gen Wallet Providers\n  const services = []\n\n  // Convert authorizations into authz services\n  if (Array.isArray(resp.authorizations)) {\n    for (let service of resp.authorizations) {\n      services.push({\n        type: \"authz\",\n        keyId: resp.keyId,\n        ...service,\n      })\n    }\n  }\n\n  // Convert Provider info into an authn service\n  if (resp.provider != null) {\n    services.push({\n      type: \"authn\",\n      id: \"wallet-provider#authn\",\n      ...resp.provider,\n    })\n  }\n\n  return services\n}\n","export function mergeServices(sx1 = [], sx2 = []) {\n  // TODO: Make this smarter\n  return [...sx1, ...sx2]\n}\n","export function urlFromService(service, includeParams = true) {\n  const url = new URL(service.endpoint)\n  if (includeParams) {\n    for (let [key, value] of Object.entries(service.params || {})) {\n      url.searchParams.append(key, value)\n    }\n  }\n  return url\n}\n","import {urlFromService} from \"./url-from-service\"\nimport {renderFrame} from \"./render-frame\"\n\nexport function renderAuthzFrame(service) {\n  var url = urlFromService(service)\n  return renderFrame(url.href)\n}\n","import {urlFromService} from \"./url-from-service\"\n\nconst METHODS = {\n  \"HTTP/GET\": \"GET\",\n  \"HTTP/POST\": \"POST\",\n}\n\nexport const pollForAuthzUpdates = service =>\n  new Promise(async (resolve, reject) => {\n    const resp = await fetch(urlFromService(service), {\n      method: METHODS[service.method],\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    }).then(d => d.json())\n\n    if (resp.status === \"APPROVED\") {\n      resolve(resp.compositeSignature)\n    } else if (resp.status === \"DECLINED\") {\n      reject({status: resp.status, reason: resp.reason})\n    } else {\n      setTimeout(() => {\n        resolve(pollForAuthzUpdates(resp.authorizationUpdates))\n      }, 500)\n    }\n  })\n","const label = (key, full) => (full == null ? `'${key}'` : `'${key}' (${full})`)\n\nconst missing = (key, full) =>\n  `Missing ${label(key, full)} in Composite Signature.`\nconst noMatch = (key, full) =>\n  `${label(\n    key,\n    full\n  )} in Composit Signature did not match the requested ${key}.`\n\nexport function validateCompositeSignature(compSig, authz) {\n  try {\n    if (compSig.addr == null) throw new Error(missing(\"addr\", \"Address\"))\n    if (compSig.keyId == null) throw new Error(missing(\"keyId\"))\n    if (compSig.signature == null) throw new Error(missing(\"signature\"))\n    if (compSig.addr !== authz.addr) throw new Error(noMatch(\"addr\", \"Address\"))\n    if (compSig.keyId !== authz.keyId) throw new Error(noMatch(\"keyId\"))\n    return compSig\n  } catch (error) {\n    console.error(error, \"\\n\\n\", {\n      \"Composite Signature\": compSig,\n      \"Authz Service\": authz,\n    })\n    throw new Error(\n      `Composite Signature from Wallet Provider failed Validation/Sanitation.\\nReason: ${error.message}`\n    )\n  }\n}\n","// Inspired by: https://github.com/lukeed/uid/blob/master/src/index.js , thank you Luke! https://github.com/lukeed\n\nvar HEX = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\nvar T = HEX.length\n\nexport function uid() {\n  var str = \"\",\n    num = 32\n  while (num--) str += HEX[(Math.random() * T) | 0]\n  return str\n}\n","import {urlFromService} from \"./url-from-service\"\nimport {renderAuthzFrame} from \"./render-authz-frame\"\nimport {pollForAuthzUpdates} from \"./poll-for-authz-updates\"\nimport {validateCompositeSignature} from \"./validate-composite-signature\"\nimport {uid} from \"./uid\"\n\nconst STRATEGIES = {\n  \"HTTP/POST\": execHttpPost,\n  \"IFRAME/RPC\": execIframeRPC,\n}\n\nexport async function execAuthzService(authz, signable) {\n  const compSig = await STRATEGIES[authz.method](authz, signable)\n  if (compSig.sig == null) compSig.sig = compSig.signature\n  if (compSig.signature == null) compSig.signature = compSig.sig\n  validateCompositeSignature(compSig, authz)\n  return compSig\n}\n\nasync function execHttpPost(authz, signable) {\n  var unrender = () => {}\n  var result = null\n  try {\n    const resp = await fetch(urlFromService(authz), {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: signable ? JSON.stringify(signable) : undefined,\n    }).then(d => d.json())\n\n    if (resp.local && resp.local.length > 0) {\n      const [_, unmount] = renderAuthzFrame(resp.local[0])\n      unrender = unmount\n    }\n\n    result = await pollForAuthzUpdates(resp.authorizationUpdates)\n  } catch (error) {\n    unrender()\n    trouble(authz, signable, error)\n    throw error\n  } finally {\n    unrender()\n    return result\n  }\n}\n\nasync function execIframeRPC(authz, signable) {\n  return new Promise((resolve, reject) => {\n    try {\n      const id = uid()\n      const [$frame, unmount] = renderAuthzFrame(authz)\n      setTimeout(() => {\n        $frame.contentWindow.postMessage(\n          JSON.parse(\n            JSON.stringify({\n              jsonrpc: \"2.0\",\n              id,\n              method: \"fcl:sign\",\n              params: [signable, authz.params],\n            })\n          ),\n          \"*\"\n        )\n      }, 500)\n\n      const replyFn = async ({data}) => {\n        if (typeof data !== \"object\") return\n        if (data.jsonrpc !== \"2.0\") return\n        if (data.id !== id) return\n\n        const result = data.result\n\n        if (result.status === \"APPROVED\") {\n          window.removeEventListener(\"message\", replyFn)\n          unmount()\n          resolve(result.compositeSignature)\n        } else if (result.status === \"DECLINED\") {\n          window.removeEventListener(\"message\", replyFn)\n          unmount()\n          reject({status: result.status, reason: result.reason})\n        } else {\n          window.removeEventListener(\"message\", replyFn)\n          unmount()\n          reject({\n            status: \"DECLINED\",\n            reason: \"Status was neither APPROVED nor DECLINED\",\n          })\n        }\n      }\n\n      window.addEventListener(\"message\", replyFn)\n    } catch (error) {\n      trouble(authz, signable, error)\n      reject({status: \"DECLINED\", reason: \"Trouble talking to Wallet Provider\"})\n    }\n  })\n}\n\nfunction trouble(authz, signable, error) {\n  console.error(\n    `[${authz.method}] Trouble talking to Wallet Provider`,\n    \"\\n\\n\",\n    {authz, signable},\n    error\n  )\n}\n","import \"../default-config\"\nimport {getAccount} from \"@onflow/sdk\"\nimport {Identity} from \"@onflow/types\"\nimport {config} from \"@onflow/config\"\nimport {spawn, send, INIT, SUBSCRIBE, UNSUBSCRIBE} from \"@onflow/util-actor\"\nimport {send as fclSend} from \"../send\"\nimport {renderAuthnFrame} from \"./render-authn-frame\"\nimport {fetchServices} from \"./fetch-services\"\nimport {mergeServices} from \"./merge-services\"\nimport {serviceOfType} from \"./service-of-type\"\nimport {execAuthzService} from \"./exec-authz-service\"\nimport {validateCompositeSignature} from \"./validate-composite-signature\"\n\nconst NAME = \"CURRENT_USER\"\nconst UPDATED = \"CURRENT_USER/UPDATED\"\nconst SNAPSHOT = \"SNAPSHOT\"\nconst SET_CURRENT_USER = \"SET_CURRENT_USER\"\nconst DEL_CURRENT_USER = \"DEL_CURRENT_USER\"\nconst GET_AS_PARAM = \"GET_AS_PARAM\"\n\nconst CHALLENGE_RESPONSE_EVENT = \"FCL::CHALLENGE::RESPONSE\"\n\nconst DATA = `{\n  \"VERSION\": \"0.2.0\",\n  \"addr\":null,\n  \"cid\":null,\n  \"loggedIn\":null,\n  \"services\":[]\n}`\n\nconst coldStorage = {\n  get: async () => {\n    const fallback = JSON.parse(DATA)\n    const stored = JSON.parse(localStorage.getItem(NAME))\n    if (stored != null && fallback.VERSION !== stored.VERSION) {\n      localStorage.removeItem(NAME)\n      return fallback\n    }\n    return stored || fallback\n  },\n  put: async data => {\n    localStorage.setItem(NAME, JSON.stringify(data))\n    return data\n  },\n}\n\nconst HANDLERS = {\n  [INIT]: async ctx => {\n    ctx.merge(await coldStorage.get())\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from)\n    ctx.send(letter.from, UPDATED, ctx.all())\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from)\n  },\n  [SNAPSHOT]: async (ctx, letter) => {\n    letter.reply(ctx.all())\n  },\n  [SET_CURRENT_USER]: async (ctx, letter, data) => {\n    ctx.merge(data)\n    coldStorage.put(ctx.all())\n    ctx.broadcast(UPDATED, ctx.all())\n  },\n  [DEL_CURRENT_USER]: async (ctx, letter) => {\n    ctx.merge(JSON.parse(DATA))\n    coldStorage.put(ctx.all())\n    ctx.broadcast(UPDATED, ctx.all())\n  },\n  [GET_AS_PARAM]: async (ctx, letter, {key}) => {\n    letter.reply({key, value: ctx.get(\"addr\", null), xform: Identity})\n  },\n}\n\nconst identity = v => v\nconst spawnCurrentUser = () => spawn(HANDLERS, NAME)\n\nasync function authenticate() {\n  return new Promise(async resolve => {\n    spawnCurrentUser()\n    const user = await snapshot()\n    if (user.loggedIn) return resolve(user)\n\n    const [$frame, unrender] = renderAuthnFrame({\n      handshake: await config().get(\"challenge.handshake\"),\n      l6n: window.location.origin,\n    })\n\n    const replyFn = async ({data}) => {\n      if (data.type !== CHALLENGE_RESPONSE_EVENT) return\n      unrender()\n      window.removeEventListener(\"message\", replyFn)\n\n      const msg = {\n        addr: data.addr,\n        cid: `did:fcl:${data.addr}`,\n        loggedIn: true,\n        services: mergeServices(\n          data.services || [],\n          await fetchServices(data.hks, data.code)\n        ),\n      }\n\n      send(NAME, SET_CURRENT_USER, msg)\n      resolve(await snapshot())\n    }\n\n    window.addEventListener(\"message\", replyFn)\n  })\n}\n\nfunction unauthenticate() {\n  spawnCurrentUser()\n  send(NAME, DEL_CURRENT_USER)\n}\n\nasync function authorization(account) {\n  spawnCurrentUser()\n  const user = await authenticate()\n  const authz = serviceOfType(user.services, \"authz\")\n\n  let sequenceNum\n  if (account.role.proposer) {\n    const acct = await info()\n    const key = acct.keys.find(key => key.index === authz.keyId)\n    sequenceNum = key.sequenceNumber\n  }\n\n  const signingFunction = async signable => execAuthzService(authz, signable)\n\n  return {\n    ...account,\n    addr: authz.addr,\n    keyId: authz.keyId,\n    sequenceNum,\n    signature: account.signature || null,\n    signingFunction,\n    resolve: null,\n    roles: account.roles,\n  }\n}\n\nfunction param(key) {\n  return async function innerParam() {\n    spawnCurrentUser()\n    await authenticate()\n    return send(NAME, GET_AS_PARAM, {key}, {expectReply: true, timeout: 10})\n  }\n}\n\nfunction subscribe(callback) {\n  spawnCurrentUser()\n  const EXIT = \"@EXIT\"\n  const self = spawn(async ctx => {\n    ctx.send(NAME, SUBSCRIBE)\n    while (1) {\n      const letter = await ctx.receive()\n      if (letter.tag === EXIT) {\n        ctx.send(NAME, UNSUBSCRIBE)\n        return\n      }\n      callback(letter.data)\n    }\n  })\n  return () => send(self, EXIT)\n}\n\nfunction snapshot() {\n  spawnCurrentUser()\n  return send(NAME, SNAPSHOT, null, {expectReply: true, timeout: 0})\n}\n\nasync function info() {\n  spawnCurrentUser()\n  const {addr} = await snapshot()\n  if (addr == null) throw new Error(\"No Flow Address for Current User\")\n  const {account} = await fclSend([getAccount(addr)])\n  return account\n}\n\nexport const currentUser = () => {\n  return {\n    authenticate,\n    unauthenticate,\n    authorization,\n    param,\n    subscribe,\n    snapshot,\n  }\n}\n","import {renderFrame} from \"./render-frame\"\n\nexport function renderAuthnFrame({handshake, l6n}) {\n  var url = new URL(handshake)\n  url.searchParams.append(\"l6n\", l6n)\n  return renderFrame(url.href)\n}\n","export function serviceOfType(services = [], type) {\n  return services.find(service => service.type === type)\n}\n","import \"./default-config\"\nexport {config} from \"@onflow/config\"\nexport {send} from \"./send\"\nexport {serialize} from \"./serialize\"\nexport {decode} from \"./decode\"\nexport {transaction as tx} from \"./transaction\"\nexport {resolve} from \"./resolve\"\nexport {events} from \"./events\"\nexport {withPrefix, sansPrefix} from \"./address\"\n\nimport {currentUser} from \"./current-user\"\nexport {currentUser}\n\nexport const authenticate = () => currentUser().authenticate()\nexport const unauthenticate = () => currentUser().unauthenticate()\n\n// proxy sdk\nexport {isOk, isBad, why, cadence, cdc} from \"@onflow/sdk\"\nexport {\n  build,\n  pipe,\n  transaction,\n  script,\n  ping,\n  getAccount,\n  getEvents,\n  getLatestBlock,\n  getBlockByHeight,\n  getBlockById,\n  getTransactionStatus,\n} from \"@onflow/sdk\"\nexport {\n  authorizations,\n  authorization,\n  args,\n  arg,\n  params,\n  param,\n  proposer,\n  payer,\n  limit,\n  ref,\n} from \"@onflow/sdk\"\n\nexport const VERSION = \"0.0.56\"\n"],"names":["config","put","resolve","async","sdkResolve","ix","resolveRefBlockId","node","get","resolveParams","resolveArguments","resolveAccounts","resolveSignatures","resolveValidators","send","args","opts","Array","isArray","build","sdkSend","serialize","JSON","stringify","decode","decodersFromConfig","where","decoders","Object","fromEntries","entries","map","pattern","xform","replace","decodeResponse","response","fetchTxStatus","fclSend","getTransactionStatus","transactionId","isSealed","tx","status","isExecuted","isFinalized","HANDLERS","[object Object]","INIT","ctx","self","setTimeout","sendSelf","merge","SUBSCRIBE","letter","subscribe","from","UPDATED","all","UNSUBSCRIBE","unsubscribe","SNAPSHOT","reply","POLL","cur","next","broadcast","scoped","Error","spawnTransaction","spawn","transaction","callback","subscriber","once","predicate","suppress","Promise","reject","unsub","txStatus","statusCode","errorMessage","snapshot","snapshoter","onceFinalized","onceExecuted","onceSealed","isUnknown","isPending","isExpired","currentBlock","getLatestBlock","scheduleTick","TICK","hasSubs","hwm","resp","getEvents","height","data","d","clearTimeout","delete","spawnEvents","key","events","sansPrefix","address","withPrefix","renderFrame","src","document","getElementById","$frame","createElement","id","allow","style","position","top","right","left","bottom","width","display","background","frameBorder","boxSizing","border","body","append","remove","fetchServices","servicesURL","code","url","URL","searchParams","fetch","method","headers","Content-Type","then","json","services","authorizations","service","push","type","keyId","provider","mergeServices","sx1","sx2","urlFromService","includeParams","endpoint","value","params","renderAuthzFrame","href","METHODS","HTTP/GET","HTTP/POST","pollForAuthzUpdates","compositeSignature","reason","authorizationUpdates","label","full","missing","noMatch","HEX","T","length","STRATEGIES","authz","signable","unrender","result","undefined","local","_","unmount","error","trouble","IFRAME/RPC","str","num","Math","random","uid","contentWindow","postMessage","parse","jsonrpc","replyFn","window","removeEventListener","addEventListener","console","NAME","DATA","coldStorage","localStorage","setItem","fallback","stored","getItem","VERSION","removeItem","SET_CURRENT_USER","DEL_CURRENT_USER","GET_AS_PARAM","Identity","spawnCurrentUser","authenticate","user","loggedIn","handshake","l6n","renderAuthnFrame","location","origin","msg","addr","cid","hks","unauthenticate","authorization","account","find","serviceOfType","sequenceNum","role","proposer","getAccount","info","keys","index","sequenceNumber","signature","signingFunction","compSig","sig","Composite Signature","Authz Service","message","validateCompositeSignature","execAuthzService","roles","param","expectReply","timeout","receive","tag","currentUser"],"mappings":"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"}