{"version":3,"file":"encode.module.js","sources":["../src/encode.js"],"sourcesContent":["const rlp = require(\"rlp\")\n\nexport const encodeTransactionPayload = tx => rlpEncode(preparePayload(tx))\nexport const encodeTransactionEnvelope = tx => rlpEncode(prepareEnvelope(tx))\n\nconst paddedHexBuffer = (value, pad) =>\n  Buffer.from(value.padStart(pad * 2, 0), \"hex\")\n\nconst addressBuffer = addr => paddedHexBuffer(addr, 8)\n\nconst blockBuffer = block => paddedHexBuffer(block, 32)\n\nconst argumentToString = arg => Buffer.from(JSON.stringify(arg), \"utf8\")\n\nconst scriptBuffer = script => Buffer.from(script, \"utf8\")\nconst signatureBuffer = signature => Buffer.from(signature, \"hex\")\n\nconst rlpEncode = v => {\n  return rlp.encode(v).toString(\"hex\")\n}\n\nconst preparePayload = tx => {\n  validatePayload(tx)\n\n  return [\n    scriptBuffer(tx.script),\n    tx.arguments.map(argumentToString),\n    blockBuffer(tx.refBlock),\n    tx.gasLimit,\n    addressBuffer(tx.proposalKey.address),\n    tx.proposalKey.keyId,\n    tx.proposalKey.sequenceNum,\n    addressBuffer(tx.payer),\n    tx.authorizers.map(addressBuffer),\n  ]\n}\n\nconst prepareEnvelope = tx => {\n  validateEnvelope(tx)\n\n  return [preparePayload(tx), preparePayloadSignatures(tx)]\n}\n\nconst preparePayloadSignatures = tx => {\n  const signers = collectSigners(tx)\n\n  return tx.payloadSigs\n    .map(sig => {\n      return {\n        signerIndex: signers.get(sig.address),\n        keyId: sig.keyId,\n        sig: sig.sig,\n      }\n    })\n    .sort((a, b) => {\n      if (a.signerIndex > b.signerIndex) return 1\n      if (a.signerIndex < b.signerIndex) return -1\n\n      if (a.keyId > b.keyId) return 1\n      if (a.keyId < b.keyId) return -1\n    })\n    .map(sig => {\n      return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)]\n    })\n}\n\nconst collectSigners = tx => {\n  const signers = new Map()\n  let i = 0\n\n  const addSigner = addr => {\n    if (!signers.has(addr)) {\n      signers.set(addr, i)\n      i++\n    }\n  }\n\n  addSigner(tx.proposalKey.address)\n  addSigner(tx.payer)\n  tx.authorizers.forEach(addSigner)\n\n  return signers\n}\n\nconst validatePayload = tx => {\n  payloadFields.forEach(field => checkField(tx, field))\n  proposalKeyFields.forEach(field =>\n    checkField(tx.proposalKey, field, \"proposalKey\")\n  )\n}\n\nconst validateEnvelope = tx => {\n  envelopeFields.forEach(field => checkField(tx, field))\n  tx.payloadSigs.forEach((sig, index) => {\n    payloadSigFields.forEach(field =>\n      checkField(sig, field, \"payloadSigs\", index)\n    )\n  })\n}\n\nconst isNumber = v => typeof v === \"number\"\nconst isString = v => typeof v === \"string\"\nconst isObject = v => v !== null && typeof v === \"object\"\nconst isArray = v => isObject(v) && v instanceof Array\n\nconst payloadFields = [\n  {name: \"script\", check: isString},\n  {name: \"arguments\", check: isArray},\n  {name: \"refBlock\", check: isString, defaultVal: \"0\"},\n  {name: \"gasLimit\", check: isNumber},\n  {name: \"proposalKey\", check: isObject},\n  {name: \"payer\", check: isString},\n  {name: \"authorizers\", check: isArray},\n]\n\nconst proposalKeyFields = [\n  {name: \"address\", check: isString},\n  {name: \"keyId\", check: isNumber},\n  {name: \"sequenceNum\", check: isNumber},\n]\n\nconst envelopeFields = [{name: \"payloadSigs\", check: isArray}]\n\nconst payloadSigFields = [\n  {name: \"address\", check: isString},\n  {name: \"keyId\", check: isNumber},\n  {name: \"sig\", check: isString},\n]\n\nconst checkField = (obj, field, base, index) => {\n  const {name, check, defaultVal} = field\n  if (obj[name] == null && defaultVal != null) obj[name] = defaultVal\n  if (obj[name] == null) throw missingFieldError(name, base, index)\n  if (!check(obj[name])) throw invalidFieldError(name, base, index)\n}\n\nconst printFieldName = (field, base, index) => {\n  if (!!base)\n    return index == null ? `${base}.${field}` : `${base}.${index}.${field}`\n  return field\n}\n\nconst missingFieldError = (field, base, index) =>\n  new Error(`Missing field ${printFieldName(field, base, index)}`)\nconst invalidFieldError = (field, base, index) =>\n  new Error(`Invalid field ${printFieldName(field, base, index)}`)\n"],"names":["rlp","require","encodeTransactionPayload","tx","rlpEncode","preparePayload","encodeTransactionEnvelope","prepareEnvelope","paddedHexBuffer","value","pad","Buffer","from","padStart","addressBuffer","addr","argumentToString","arg","JSON","stringify","v","encode","toString","validatePayload","script","arguments","map","block","refBlock","gasLimit","proposalKey","address","keyId","sequenceNum","payer","authorizers","validateEnvelope","preparePayloadSignatures","signers","collectSigners","payloadSigs","sig","signerIndex","get","sort","a","b","signature","Map","i","addSigner","has","set","forEach","payloadFields","field","checkField","proposalKeyFields","envelopeFields","index","payloadSigFields","isNumber","isString","isObject","isArray","Array","name","check","defaultVal","obj","base","missingFieldError","invalidFieldError","printFieldName","Error"],"mappings":"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"}