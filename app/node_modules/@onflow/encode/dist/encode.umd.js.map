{"version":3,"file":"encode.umd.js","sources":["../src/encode.js"],"sourcesContent":["const rlp = require(\"rlp\")\n\nexport const encodeTransactionPayload = tx => rlpEncode(preparePayload(tx))\nexport const encodeTransactionEnvelope = tx => rlpEncode(prepareEnvelope(tx))\n\nconst paddedHexBuffer = (value, pad) =>\n  Buffer.from(value.padStart(pad * 2, 0), \"hex\")\n\nconst addressBuffer = addr => paddedHexBuffer(addr, 8)\n\nconst blockBuffer = block => paddedHexBuffer(block, 32)\n\nconst argumentToString = arg => Buffer.from(JSON.stringify(arg), \"utf8\")\n\nconst scriptBuffer = script => Buffer.from(script, \"utf8\")\nconst signatureBuffer = signature => Buffer.from(signature, \"hex\")\n\nconst rlpEncode = v => {\n  return rlp.encode(v).toString(\"hex\")\n}\n\nconst preparePayload = tx => {\n  validatePayload(tx)\n\n  return [\n    scriptBuffer(tx.script),\n    tx.arguments.map(argumentToString),\n    blockBuffer(tx.refBlock),\n    tx.gasLimit,\n    addressBuffer(tx.proposalKey.address),\n    tx.proposalKey.keyId,\n    tx.proposalKey.sequenceNum,\n    addressBuffer(tx.payer),\n    tx.authorizers.map(addressBuffer),\n  ]\n}\n\nconst prepareEnvelope = tx => {\n  validateEnvelope(tx)\n\n  return [preparePayload(tx), preparePayloadSignatures(tx)]\n}\n\nconst preparePayloadSignatures = tx => {\n  const signers = collectSigners(tx)\n\n  return tx.payloadSigs\n    .map(sig => {\n      return {\n        signerIndex: signers.get(sig.address),\n        keyId: sig.keyId,\n        sig: sig.sig,\n      }\n    })\n    .sort((a, b) => {\n      if (a.signerIndex > b.signerIndex) return 1\n      if (a.signerIndex < b.signerIndex) return -1\n\n      if (a.keyId > b.keyId) return 1\n      if (a.keyId < b.keyId) return -1\n    })\n    .map(sig => {\n      return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)]\n    })\n}\n\nconst collectSigners = tx => {\n  const signers = new Map()\n  let i = 0\n\n  const addSigner = addr => {\n    if (!signers.has(addr)) {\n      signers.set(addr, i)\n      i++\n    }\n  }\n\n  addSigner(tx.proposalKey.address)\n  addSigner(tx.payer)\n  tx.authorizers.forEach(addSigner)\n\n  return signers\n}\n\nconst validatePayload = tx => {\n  payloadFields.forEach(field => checkField(tx, field))\n  proposalKeyFields.forEach(field =>\n    checkField(tx.proposalKey, field, \"proposalKey\")\n  )\n}\n\nconst validateEnvelope = tx => {\n  envelopeFields.forEach(field => checkField(tx, field))\n  tx.payloadSigs.forEach((sig, index) => {\n    payloadSigFields.forEach(field =>\n      checkField(sig, field, \"payloadSigs\", index)\n    )\n  })\n}\n\nconst isNumber = v => typeof v === \"number\"\nconst isString = v => typeof v === \"string\"\nconst isObject = v => v !== null && typeof v === \"object\"\nconst isArray = v => isObject(v) && v instanceof Array\n\nconst payloadFields = [\n  {name: \"script\", check: isString},\n  {name: \"arguments\", check: isArray},\n  {name: \"refBlock\", check: isString, defaultVal: \"0\"},\n  {name: \"gasLimit\", check: isNumber},\n  {name: \"proposalKey\", check: isObject},\n  {name: \"payer\", check: isString},\n  {name: \"authorizers\", check: isArray},\n]\n\nconst proposalKeyFields = [\n  {name: \"address\", check: isString},\n  {name: \"keyId\", check: isNumber},\n  {name: \"sequenceNum\", check: isNumber},\n]\n\nconst envelopeFields = [{name: \"payloadSigs\", check: isArray}]\n\nconst payloadSigFields = [\n  {name: \"address\", check: isString},\n  {name: \"keyId\", check: isNumber},\n  {name: \"sig\", check: isString},\n]\n\nconst checkField = (obj, field, base, index) => {\n  const {name, check, defaultVal} = field\n  if (obj[name] == null && defaultVal != null) obj[name] = defaultVal\n  if (obj[name] == null) throw missingFieldError(name, base, index)\n  if (!check(obj[name])) throw invalidFieldError(name, base, index)\n}\n\nconst printFieldName = (field, base, index) => {\n  if (!!base)\n    return index == null ? `${base}.${field}` : `${base}.${index}.${field}`\n  return field\n}\n\nconst missingFieldError = (field, base, index) =>\n  new Error(`Missing field ${printFieldName(field, base, index)}`)\nconst invalidFieldError = (field, base, index) =>\n  new Error(`Invalid field ${printFieldName(field, base, index)}`)\n"],"names":["rlp","require","paddedHexBuffer","value","pad","Buffer","from","padStart","addressBuffer","addr","argumentToString","arg","JSON","stringify","rlpEncode","v","encode","toString","preparePayload","tx","validatePayload","script","arguments","map","block","refBlock","gasLimit","proposalKey","address","keyId","sequenceNum","payer","authorizers","preparePayloadSignatures","signers","collectSigners","payloadSigs","sig","signerIndex","get","sort","a","b","signature","Map","i","addSigner","has","set","forEach","payloadFields","field","checkField","proposalKeyFields","isNumber","isString","isObject","isArray","Array","name","check","defaultVal","envelopeFields","payloadSigFields","obj","base","index","missingFieldError","invalidFieldError","printFieldName","Error","validateEnvelope","prepareEnvelope"],"mappings":"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"}