{"version":3,"file":"rlp.js","sources":["../src/index.js"],"sourcesContent":["/**\n * Built on top of rlp library, removing the BN dependency for the flow.\n * Package : https://github.com/ethereumjs/rlp\n * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE\n *\n * ethereumjs/rlp is licensed under the\n * Mozilla Public License 2.0\n * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.\n **/\n\n/**\n * @param input - will be converted to buffer\n * @returns returns buffer of encoded data\n **/\nexport function encode(input) {\n  if (Array.isArray(input)) {\n    var output = []\n    for (var i = 0; i < input.length; i++) {\n      output.push(encode(input[i]))\n    }\n    var buf = Buffer.concat(output)\n    return Buffer.concat([encodeLength(buf.length, 192), buf])\n  } else {\n    var inputBuf = toBuffer(input)\n    return inputBuf.length === 1 && inputBuf[0] < 128\n      ? inputBuf\n      : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf])\n  }\n}\n\n/**\n * Parse integers. Check if there is no leading zeros\n * @param v The value to parse\n * @param base The base to parse the integer into\n */\nfunction safeParseInt(v, base) {\n  if (v.slice(0, 2) === \"00\") {\n    throw new Error(\"invalid RLP: extra zeros\")\n  }\n  return parseInt(v, base)\n}\nfunction encodeLength(len, offset) {\n  if (len < 56) {\n    return Buffer.from([len + offset])\n  } else {\n    var hexLength = intToHex(len)\n    var lLength = hexLength.length / 2\n    var firstByte = intToHex(offset + 55 + lLength)\n    return Buffer.from(firstByte + hexLength, \"hex\")\n  }\n}\n\nfunction decode(input, stream) {\n  if (stream === void 0) {\n    stream = false\n  }\n  if (!input || input.length === 0) {\n    return Buffer.from([])\n  }\n  var inputBuffer = toBuffer(input)\n  var decoded = _decode(inputBuffer)\n  if (stream) {\n    return decoded\n  }\n  if (decoded.remainder.length !== 0) {\n    throw new Error(\"invalid remainder\")\n  }\n  return decoded.data\n}\n\n/**\n * Get the length of the RLP input\n * @param input\n * @returns The length of the input or an empty Buffer if no input\n */\nexport function getLength(input) {\n  if (!input || input.length === 0) {\n    return Buffer.from([])\n  }\n  var inputBuffer = toBuffer(input)\n  var firstByte = inputBuffer[0]\n  if (firstByte <= 0x7f) {\n    return inputBuffer.length\n  } else if (firstByte <= 0xb7) {\n    return firstByte - 0x7f\n  } else if (firstByte <= 0xbf) {\n    return firstByte - 0xb6\n  } else if (firstByte <= 0xf7) {\n    // a list between  0-55 bytes long\n    return firstByte - 0xbf\n  } else {\n    // a list  over 55 bytes long\n    var llength = firstByte - 0xf6\n    var length = safeParseInt(inputBuffer.slice(1, llength).toString(\"hex\"), 16)\n    return llength + length\n  }\n}\n\n/** Decode an input with RLP */\nfunction _decode(input) {\n  var length, llength, data, innerRemainder, d\n  var decoded = []\n  var firstByte = input[0]\n  if (firstByte <= 0x7f) {\n    // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n    return {\n      data: input.slice(0, 1),\n      remainder: input.slice(1),\n    }\n  } else if (firstByte <= 0xb7) {\n    // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\n    // The range of the first byte is [0x80, 0xb7]\n    length = firstByte - 0x7f\n    // set 0x80 null to 0\n    if (firstByte === 0x80) {\n      data = Buffer.from([])\n    } else {\n      data = input.slice(1, length)\n    }\n    if (length === 2 && data[0] < 0x80) {\n      throw new Error(\"invalid rlp encoding: byte must be less 0x80\")\n    }\n    return {\n      data: data,\n      remainder: input.slice(length),\n    }\n  } else if (firstByte <= 0xbf) {\n    llength = firstByte - 0xb6\n    length = safeParseInt(input.slice(1, llength).toString(\"hex\"), 16)\n    data = input.slice(llength, length + llength)\n    if (data.length < length) {\n      throw new Error(\"invalid RLP\")\n    }\n    return {\n      data: data,\n      remainder: input.slice(length + llength),\n    }\n  } else if (firstByte <= 0xf7) {\n    // a list between  0-55 bytes long\n    length = firstByte - 0xbf\n    innerRemainder = input.slice(1, length)\n    while (innerRemainder.length) {\n      d = _decode(innerRemainder)\n      decoded.push(d.data)\n      innerRemainder = d.remainder\n    }\n    return {\n      data: decoded,\n      remainder: input.slice(length),\n    }\n  } else {\n    // a list  over 55 bytes long\n    llength = firstByte - 0xf6\n    length = safeParseInt(input.slice(1, llength).toString(\"hex\"), 16)\n    var totalLength = llength + length\n    if (totalLength > input.length) {\n      throw new Error(\"invalid rlp: total length is larger than the data\")\n    }\n    innerRemainder = input.slice(llength, totalLength)\n    if (innerRemainder.length === 0) {\n      throw new Error(\"invalid rlp, List has a invalid length\")\n    }\n    while (innerRemainder.length) {\n      d = _decode(innerRemainder)\n      decoded.push(d.data)\n      innerRemainder = d.remainder\n    }\n    return {\n      data: decoded,\n      remainder: input.slice(totalLength),\n    }\n  }\n}\n/** Check if a string is prefixed by 0x */\nfunction isHexPrefixed(str) {\n  return str.slice(0, 2) === \"0x\"\n}\n/** Removes 0x from a given String */\nfunction stripHexPrefix(str) {\n  if (typeof str !== \"string\") {\n    return str\n  }\n  return isHexPrefixed(str) ? str.slice(2) : str\n}\n/** Transform an integer into its hexadecimal value */\nfunction intToHex(integer) {\n  if (integer < 0) {\n    throw new Error(\"Invalid integer as argument, must be unsigned!\")\n  }\n  var hex = integer.toString(16)\n  return hex.length % 2 ? \"0\" + hex : hex\n}\n/** Pad a string to be even */\nfunction padToEven(a) {\n  return a.length % 2 ? \"0\" + a : a\n}\n/** Transform an integer into a Buffer */\nfunction intToBuffer(integer) {\n  var hex = intToHex(integer)\n  return Buffer.from(hex, \"hex\")\n}\n\n/** Transform anything into a Buffer */\nexport function toBuffer(v) {\n  if (!Buffer.isBuffer(v)) {\n    if (typeof v === \"string\") {\n      if (isHexPrefixed(v)) {\n        return Buffer.from(padToEven(stripHexPrefix(v)), \"hex\")\n      } else {\n        return Buffer.from(v)\n      }\n    } else if (typeof v === \"number\") {\n      if (!v) {\n        return Buffer.from([])\n      } else {\n        return intToBuffer(v)\n      }\n    } else if (v === null || v === undefined) {\n      return Buffer.from([])\n    } else if (v instanceof Uint8Array) {\n      return Buffer.from(v)\n    } else {\n      throw new Error(\"invalid type\")\n    }\n  }\n  return v\n}\n"],"names":["encodeLength","len","offset","Buffer","from","hexLength","intToHex","firstByte","length","isHexPrefixed","str","slice","integer","Error","hex","toString","toBuffer","v","isBuffer","a","Uint8Array","encode","input","Array","isArray","output","i","push","buf","concat","inputBuf","inputBuffer","llength","base","parseInt","safeParseInt"],"mappings":"AAyCA,SAASA,EAAaC,EAAKC,GACzB,GAAID,EAAM,GACR,OAAOE,OAAOC,KAAK,CAACH,EAAMC,IAE1B,IAAIG,EAAYC,EAASL,GAErBM,EAAYD,EAASJ,EAAS,GADpBG,EAAUG,OAAS,GAEjC,OAAOL,OAAOC,KAAKG,EAAYF,EAAW,OA8H9C,SAASI,EAAcC,GACrB,MAA2B,OAApBA,EAAIC,MAAM,EAAG,GAUtB,SAASL,EAASM,GAChB,GAAIA,EAAU,EACZ,UAAUC,MAAM,kDAElB,IAAIC,EAAMF,EAAQG,SAAS,IAC3B,OAAOD,EAAIN,OAAS,EAAI,IAAMM,EAAMA,WAatBE,EAASC,GACvB,IAAKd,OAAOe,SAASD,GAAI,CACvB,GAAiB,iBAANA,EACT,OAAIR,EAAcQ,GACTd,OAAOC,MAdHe,EAdE,iBADGT,EA6B4BO,GA3BzCP,EAEFD,EAAcC,GAAOA,EAAIC,MAAM,GAAKD,GAYlCF,OAAS,EAAI,IAAMW,EAAIA,EAauB,OAE1ChB,OAAOC,KAAKa,MAEC,iBAANA,EAChB,OAAKA,GAdLH,EAAMR,EAiBeW,GAhBlBd,OAAOC,KAAKU,EAAK,QAcXX,OAAOC,KAAK,OAIZa,MAAAA,EACT,OAAOd,OAAOC,KAAK,OACVa,aAAaG,WACtB,OAAOjB,OAAOC,KAAKa,GAEnB,UAAUJ,MAAM,gBAzBtB,IACMC,EALaK,EAfKT,EA+CtB,OAAOO,0BAnNOI,EAAOC,GACrB,GAAIC,MAAMC,QAAQF,GAAQ,CAExB,IADA,IAAIG,EAAS,GACJC,EAAI,EAAGA,EAAIJ,EAAMd,OAAQkB,IAChCD,EAAOE,KAAKN,EAAOC,EAAMI,KAE3B,IAAIE,EAAMzB,OAAO0B,OAAOJ,GACxB,OAAOtB,OAAO0B,OAAO,CAAC7B,EAAa4B,EAAIpB,OAAQ,KAAMoB,IAErD,IAAIE,EAAWd,EAASM,GACxB,OAA2B,IAApBQ,EAAStB,QAAgBsB,EAAS,GAAK,IAC1CA,EACA3B,OAAO0B,OAAO,CAAC7B,EAAa8B,EAAStB,OAAQ,KAAMsB,gCAiDjCR,GACxB,IAAKA,GAA0B,IAAjBA,EAAMd,OAClB,OAAOL,OAAOC,KAAK,IAErB,IAAI2B,EAAcf,EAASM,GACvBf,EAAYwB,EAAY,GAC5B,GAAIxB,GAAa,IACf,OAAOwB,EAAYvB,UACVD,GAAa,IACtB,OAAOA,EAAY,OACVA,GAAa,IACtB,OAAOA,EAAY,OACVA,GAAa,IAEtB,OAAOA,EAAY,IAGnB,IAAIyB,EAAUzB,EAAY,IAE1B,OAAOyB,EA3DX,SAAsBf,EAAGgB,GACvB,GAAsB,OAAlBhB,EAAEN,MAAM,EAAG,GACb,UAAUE,MAAM,4BAElB,OAAOqB,SAASjB,EAsD2D,IAA5DkB,CAAaJ,EAAYpB,MAAM,EAAGqB,GAASjB,SAAS"}