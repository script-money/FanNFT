var t=function(t,n,e){return{label:t,asArgument:n,asInjection:e}},n=function(t){return Array.isArray(t)},e=function(t){return"object"==typeof t},r=function(t){return null==t},u=function(t){return"number"==typeof t},i=function(t){return Number.isInteger(t)},o=function(t){return"string"==typeof t},f=function(t){throw new Error("Type Error: "+t)},c=t("Identity",function(t){return t},function(t){return t}),a=t("UInt",function(t){if(u(t)&&i(t))return{type:"UInt",value:t.toString()};f("Expected Positive Integer for type Unsigned Int")},function(t){return t}),p=t("Int",function(t){if(u(t)&&i(t))return{type:"Int",value:t.toString()};f("Expected Integer for type Int")},function(t){return t}),l=t("UInt8",function(t){if(u(t)&&i(t))return{type:"UInt8",value:t.toString()};f("Expected integer for UInt8")},function(t){return t}),d=t("Int8",function(t){if(u(t)&&i(t))return{type:"Int8",value:t.toString()};f("Expected positive integer for Int8")},function(t){return t}),v=t("UInt16",function(t){if(u(t)&&i(t))return{type:"UInt16",value:t.toString()};f("Expected integer for UInt16")},function(t){return t}),s=t("Int16",function(t){if(u(t)&&i(t))return{type:"Int16",value:t.toString()};f("Expected positive integer for Int16")},function(t){return t}),y=t("UInt32",function(t){if(u(t)&&i(t))return{type:"UInt32",value:t.toString()};f("Expected integer for UInt32")},function(t){return t}),g=t("Int32",function(t){if(u(t)&&i(t))return{type:"Int32",value:t.toString()};f("Expected positive integer for Int32")},function(t){return t}),m=t("UInt64",function(t){if(u(t)&&i(t))return{type:"UInt64",value:t.toString()};f("Expected integer for UInt64")},function(t){return t}),I=t("Int64",function(t){if(u(t)&&i(t))return{type:"Int64",value:t.toString()};f("Expected positive integer for Int64")},function(t){return t}),x=t("UInt128",function(t){if(u(t)&&i(t))return{type:"UInt128",value:t.toString()};f("Expected integer for UInt128")},function(t){return t}),E=t("Int128",function(t){if(u(t)&&i(t))return{type:"Int128",value:t.toString()};f("Expected positive integer for Int128")},function(t){return t}),S=t("UInt256",function(t){if(u(t)&&i(t))return{type:"UInt256",value:t.toString()};f("Expected integer for UInt256")},function(t){return t}),U=t("Int256",function(t){if(u(t)&&i(t))return{type:"Int256",value:t.toString()};f("Expected integer for Int256")},function(t){return t}),A=t("Word8",function(t){if(u(t)&&i(t))return{type:"Word8",value:t.toString()};f("Expected positive number for Word8")},function(t){return t}),b=t("Word16",function(t){if(u(t)&&i(t))return{type:"Word16",value:t.toString()};f("Expected positive number for Word16")},function(t){return t}),W=t("Word32",function(t){if(u(t)&&i(t))return{type:"Word32",value:t.toString()};f("Expected positive number for Word32")},function(t){return t}),k=t("Word64",function(t){if(u(t)&&i(t))return{type:"Word64",value:t.toString()};f("Expected positive number for Word64")},function(t){return t}),F=function(){console.error("\n          %c@onflow/types Deprecation Notice\n          ========================\n\n          Passing in Numbers as values for Fix64 and UFix64 types is deprecated and will cease to work in future releases of @onflow/types.\n          Find out more here: https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0001-[U]Fix64-as-Number\n\n          =======================\n        ".replace(/\n\s+/g,"\n").trim(),"font-weight:bold;font-family:monospace;")},h=t("UFix64",function(t){return o(t)?{type:"UFix64",value:t}:u(t)?(F(),{type:"UFix64",value:t.toString()}):void f("Expected String for UFix64")},function(t){return t}),w=t("Fix64",function(t){return o(t)?{type:"Fix64",value:t}:u(t)?(F(),{type:"Fix64",value:t.toString()}):void f("Expected String for Fix64")},function(t){return t}),j=t("String",function(t){if(o(t))return{type:"String",value:t};f("Expected String for type String")},function(t){return t}),O=t("Character",function(t){if(o(t))return{type:"Character",value:t};f("Expected Character for type Character")},function(t){return t}),R=t("Bool",function(t){if("boolean"==typeof t)return{type:"Bool",value:t};f("Expected Boolean for type Bool")},function(t){return t}),N=t("Address",function(t){if(o(t))return{type:"Address",value:t};f("Expected Address for type Address")},function(t){return t}),B=t("Void",function(t){if(!t||r(t))return{type:"Void"};f("Expected Void for type Void")},function(t){return t}),C=function(n){return t("Optional",function(t){return{type:"Optional",value:r(t)?null:n.asArgument(t)}},function(t){return t})},D=t("Reference",function(t){if(e(t))return{type:"Reference",value:t};f("Expected Object for type Reference")},function(t){return t}),V=function(e){return void 0===e&&(e=[]),t("Array",function(t){return{type:"Array",value:n(e)?e.map(function(n,e){return n.asArgument(t[e])}):t.map(function(t){return e.asArgument(t)})}},function(t){return t})},P=function(r){return void 0===r&&(r=[]),t("Dictionary",function(t){if(e(t))return{type:"Dictionary",value:n(r)?r.map(function(n,e){return{key:n.key.asArgument(t[e].key),value:n.value.asArgument(t[e].value)}}):n(t)?t.map(function(t){return{key:r.key.asArgument(t.key),value:r.value.asArgument(t.value)}}):[{key:r.key.asArgument(t.key),value:r.value.asArgument(t.value)}]};f("Expected Object for type Dictionary")},function(t){return t})},G=function(r,u){return void 0===u&&(u=[]),t("Event",function(t){if(e(t))return{type:"Event",value:{id:r,fields:n(u)?u.map(function(n,e){return{name:t.fields[e].name,value:n.value.asArgument(t.fields[e].value)}}):t.fields.map(function(t){return{name:t.name,value:u.value.asArgument(t.value)}})}};f("Expected Object for type Event")},function(t){return t})},T=function(r,u){return void 0===u&&(u=[]),t("Resource",function(t){if(e(t))return{type:"Resource",value:{id:r,fields:n(u)?u.map(function(n,e){return{name:t.fields[e].name,value:n.value.asArgument(t.fields[e].value)}}):t.fields.map(function(t){return{name:t.name,value:u.value.asArgument(t.value)}})}};f("Expected Object for type Resource")},function(t){return t})},q=function(r,u){return void 0===u&&(u=[]),t("Struct",function(t){if(e(t))return{type:"Struct",value:{id:r,fields:n(u)?u.map(function(n,e){return{name:t.fields[e].name,value:n.value.asArgument(t.fields[e].value)}}):t.fields.map(function(t){return{name:t.name,value:u.value.asArgument(t.value)}})}};f("Expected Object for type Struct")},function(t){return t})};export{N as Address,V as Array,R as Bool,O as Character,P as Dictionary,G as Event,w as Fix64,c as Identity,p as Int,E as Int128,s as Int16,U as Int256,g as Int32,I as Int64,d as Int8,C as Optional,D as Reference,T as Resource,j as String,q as Struct,h as UFix64,a as UInt,x as UInt128,v as UInt16,S as UInt256,y as UInt32,m as UInt64,l as UInt8,B as Void,b as Word16,W as Word32,k as Word64,A as Word8,V as _Array};
//# sourceMappingURL=types.module.js.map
