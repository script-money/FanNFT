import e from"queue-microtask";const t=()=>{const e=[];var t;return{async deliver(s){e.push(s),t&&(t(e.shift()),t=void 0)},receive:()=>new Promise(function(s){const o=e.shift();if(o)return s(o);t=s})}},s="INIT",o="SUBSCRIBE",r="UNSUBSCRIBE",n="UPDATED",l="SNAPSHOT",R="EXIT",a="TERMINATE",i="object"==typeof self&&self.self===self&&self||"object"==typeof global&&global.global===global&&global||"object"==typeof window&&window.window===window&&window;i.FCL_REGISTRY=null==i.FCL_REGISTRY?{}:i.FCL_REGISTRY;var u=0;const c=(e,t,s,o={})=>new Promise((r,n)=>{const l=o.expectReply||!1,R=null!=o.timeout?o.timeout:5e3;l&&R&&setTimeout(()=>n(new Error(`Timeout: ${R}ms passed without a response.`)),R);const a={to:e,from:o.from,tag:t,data:s,timeout:R,reply:r,reject:n};try{i.FCL_REGISTRY[e].mailbox.deliver(a),l||r(!0)}catch(e){console.error("FCL.Actor -- Could Not Deliver Message",a,e)}}),E=e=>{delete i.FCL_REGISTRY[e]},T=(s,o=null)=>{if(null==o&&(o=++u),null!=i.FCL_REGISTRY[o])return o;i.FCL_REGISTRY[o]={addr:o,mailbox:t(),subs:new Set,kvs:{}};const r={self:()=>o,receive:()=>i.FCL_REGISTRY[o].mailbox.receive(),send:(e,t,s,r={})=>(r.from=o,c(e,t,s,r)),sendSelf:(e,t,s)=>{i.FCL_REGISTRY[o]&&c(o,e,t,s)},broadcast:(e,t,s={})=>{s.from=o;for(let r of i.FCL_REGISTRY[o].subs)c(r,e,t,s)},subscribe:e=>null!=e&&i.FCL_REGISTRY[o].subs.add(e),unsubscribe:e=>null!=e&&i.FCL_REGISTRY[o].subs.delete(e),subscriberCount:()=>i.FCL_REGISTRY[o].subs.size,hasSubs:()=>!!i.FCL_REGISTRY[o].subs.size,put:(e,t)=>{null!=e&&(i.FCL_REGISTRY[o].kvs[e]=t)},get:(e,t)=>{const s=i.FCL_REGISTRY[o].kvs[e];return null==s?t:s},delete:e=>{delete i.FCL_REGISTRY[o].kvs[e]},update:(e,t)=>{null!=e&&(i.FCL_REGISTRY[o].kvs[e]=t(i.FCL_REGISTRY[o].kvs[e]))},keys:()=>Object.keys(i.FCL_REGISTRY[o].kvs),all:()=>i.FCL_REGISTRY[o].kvs,where:e=>Object.keys(i.FCL_REGISTRY[o].kvs).reduce((t,s)=>e.test(s)?{...t,[s]:i.FCL_REGISTRY[o].kvs[s]}:t,{}),merge:(e={})=>{Object.keys(e).forEach(t=>i.FCL_REGISTRY[o].kvs[t]=e[t])}};return"object"==typeof s&&(s=((e={})=>async t=>{"function"==typeof e.INIT&&await e.INIT(t);e:for(;;){const s=await t.receive();try{if("EXIT"===s.tag){"function"==typeof e.TERMINATE&&await e.TERMINATE(t,s,s.data||{});break e}await e[s.tag](t,s,s.data||{})}catch(e){console.error(t.self()+" Error",s,e)}finally{continue e}}})(s)),e(async()=>{await s(r),E(o)}),o};function I(e,t,s){t(e);const o=T(async t=>{for(t.send(e,"SUBSCRIBE");;){const o=await t.receive();if("@EXIT"===o.tag)return void t.send(e,"UNSUBSCRIBE");s(o.data)}});return()=>c(o,"@EXIT")}function S(e,t){return t(e),c(e,"SNAPSHOT",null,{expectReply:!0,timeout:0})}export{R as EXIT,s as INIT,l as SNAPSHOT,o as SUBSCRIBE,a as TERMINATE,r as UNSUBSCRIBE,n as UPDATED,E as kill,c as send,S as snapshoter,T as spawn,I as subscriber};
//# sourceMappingURL=actor.modern.js.map
