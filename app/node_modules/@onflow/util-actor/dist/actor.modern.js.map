{"version":3,"file":"actor.modern.js","sources":["../src/mailbox/index.js","../src/index.js"],"sourcesContent":["export const mailbox = () => {\n  const queue = []\n  var next\n\n  return {\n    async deliver(msg) {\n      queue.push(msg)\n      if (next) {\n        next(queue.shift())\n        next = undefined\n      }\n    },\n\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift()\n        if (msg) return resolve(msg)\n        next = resolve\n      })\n    },\n  }\n}\n","import {mailbox as createMailbox} from \"./mailbox\"\nimport queueMicrotask from \"queue-microtask\"\n\nexport const INIT = \"INIT\"\nexport const SUBSCRIBE = \"SUBSCRIBE\"\nexport const UNSUBSCRIBE = \"UNSUBSCRIBE\"\nexport const UPDATED = \"UPDATED\"\nexport const SNAPSHOT = \"SNAPSHOT\"\nexport const EXIT = \"EXIT\"\nexport const TERMINATE = \"TERMINATE\"\n\nconst root =\n  (typeof self === \"object\" && self.self === self && self) ||\n  (typeof global === \"object\" && global.global === global && global) ||\n  (typeof window === \"object\" && window.window === window && window)\n\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY\nvar pid = 0b0\n\nconst DEFAULT_TIMEOUT = 5000\nconst DEFAULT_TAG = \"---\"\nexport const send = (addr, tag, data, opts = {}) =>\n  new Promise((reply, reject) => {\n    const expectReply = opts.expectReply || false\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT\n\n    if (expectReply && timeout) {\n      setTimeout(\n        () =>\n          reject(new Error(`Timeout: ${timeout}ms passed without a response.`)),\n        timeout\n      )\n    }\n\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply,\n      reject,\n    }\n\n    try {\n      root.FCL_REGISTRY[addr].mailbox.deliver(payload)\n      if (!expectReply) reply(true)\n    } catch (error) {\n      console.error(\"FCL.Actor -- Could Not Deliver Message\", payload, error)\n    }\n  })\n\nexport const kill = addr => {\n  delete root.FCL_REGISTRY[addr]\n}\n\nconst fromHandlers = (handlers = {}) => async ctx => {\n  if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx)\n  __loop: while (1) {\n    const letter = await ctx.receive()\n    try {\n      if (letter.tag === EXIT) {\n        if (typeof handlers[TERMINATE] === \"function\") {\n          await handlers[TERMINATE](ctx, letter, letter.data || {})\n        }\n        break __loop\n      }\n      await handlers[letter.tag](ctx, letter, letter.data || {})\n    } catch (error) {\n      console.error(`${ctx.self()} Error`, letter, error)\n    } finally {\n      continue __loop\n    }\n  }\n}\n\nexport const spawn = (fn, addr = null) => {\n  if (addr == null) addr = ++pid\n  if (root.FCL_REGISTRY[addr] != null) return addr\n\n  root.FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: createMailbox(),\n    subs: new Set(),\n    kvs: {},\n  }\n\n  const ctx = {\n    self: () => addr,\n    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),\n    send: (to, tag, data, opts = {}) => {\n      opts.from = addr\n      return send(to, tag, data, opts)\n    },\n    sendSelf: (tag, data, opts) => {\n      if (root.FCL_REGISTRY[addr]) send(addr, tag, data, opts)\n    },\n    broadcast: (tag, data, opts = {}) => {\n      opts.from = addr\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts)\n    },\n    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),\n    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),\n    subscriberCount: () => root.FCL_REGISTRY[addr].subs.size,\n    hasSubs: () => !!root.FCL_REGISTRY[addr].subs.size,\n    put: (key, value) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value\n    },\n    get: (key, fallback) => {\n      const value = root.FCL_REGISTRY[addr].kvs[key]\n      return value == null ? fallback : value\n    },\n    delete: key => {\n      delete root.FCL_REGISTRY[addr].kvs[key]\n    },\n    update: (key, fn) => {\n      if (key != null)\n        root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key])\n    },\n    keys: () => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs)\n    },\n    all: () => {\n      return root.FCL_REGISTRY[addr].kvs\n    },\n    where: pattern => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n        return pattern.test(key)\n          ? {...acc, [key]: root.FCL_REGISTRY[addr].kvs[key]}\n          : acc\n      }, {})\n    },\n    merge: (data = {}) => {\n      Object.keys(data).forEach(\n        key => (root.FCL_REGISTRY[addr].kvs[key] = data[key])\n      )\n    },\n  }\n\n  if (typeof fn === \"object\") fn = fromHandlers(fn)\n\n  queueMicrotask(async () => {\n    await fn(ctx)\n    kill(addr)\n  })\n\n  return addr\n}\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nexport function subscriber(address, spawnFn, callback) {\n  spawnFn(address)\n  const EXIT = \"@EXIT\"\n  const self = spawn(async ctx => {\n    ctx.send(address, SUBSCRIBE)\n    while (1) {\n      const letter = await ctx.receive()\n      if (letter.tag === EXIT) {\n        ctx.send(address, UNSUBSCRIBE)\n        return\n      }\n      callback(letter.data)\n    }\n  })\n  return () => send(self, EXIT)\n}\n\n// Returns a promise that returns a result\n// A SNAPSHOT handler will need to be created to handle the snapshot event\n//\n//  [SNAPSHOT]: (ctx, letter) => {\n//    letter.reply(ctx.all())\n//  }\n//\nexport function snapshoter(address, spawnFn) {\n  spawnFn(address)\n  return send(address, SNAPSHOT, null, {expectReply: true, timeout: 0})\n}\n"],"names":["mailbox","queue","next","[object Object]","msg","push","shift","undefined","receive","Promise","resolve","INIT","SUBSCRIBE","UNSUBSCRIBE","UPDATED","SNAPSHOT","EXIT","TERMINATE","root","self","global","window","FCL_REGISTRY","pid","send","addr","tag","data","opts","reply","reject","expectReply","timeout","setTimeout","Error","payload","to","from","deliver","error","console","kill","spawn","fn","createMailbox","subs","Set","kvs","ctx","sendSelf","broadcast","subscribe","sub","add","unsubscribe","delete","subscriberCount","size","hasSubs","put","key","value","get","fallback","update","keys","Object","all","where","pattern","reduce","acc","test","merge","forEach","handlers","async","__loop","letter","fromHandlers","queueMicrotask","subscriber","address","spawnFn","callback","snapshoter"],"mappings":"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"}